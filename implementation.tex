%!TEX root = 2024-cmsb_tool.tex
CLUE is designed as an open source python library to be used for model analysis and exploration.
The architecture of CLUE has been planned for efficient interaction and data handling through three main components:
\emph{ model input}, \emph{core functionalities}, and \emph{outputs}. 
The model input component handles the steps of model acquisition and processing.
The core functionalities component, instead, contains all the logic to apply model reduction onto the models.
The outputs component formats simulations and allows for preliminary data analysis. 
The architecture of CLUE is summarized in Figure~\ref{fig:clue_arch}.
We now proceed to explain each component in detail.
%Explain the software architecture of the project 
\begin{figure}
	\centering
	\includegraphics[width=\textwidth]{img/clue.pdf}
	\caption{Architecture of \ToolName(red).
        The arrows indicate data flow.
        The components of CLUE (blue) are composed of modules (green) of which the main classes and methods (e.g., \texttt{lumping}) are mentioned (orange).
        External files and sources are displayed in purple.
     }
	\label{fig:clue_arch}
\end{figure}
%We now provide a detailed description of each component.

\subsection{Model Input}
The main goal of this component is to construct instances of the \texttt{FODEsystem} class from the supported sources: ODEBase~\cite{LuedersSturmRadulescu22},  ERODE~\cite{cardelli_erode_2017} \texttt{.ode} files, and systems of ODEs using \texttt{sympy}.
The module \texttt{odebase\_io.py} allows the modeler to fetch models from ODEBase~\cite{LuedersSturmRadulescu22} as instances of \texttt{FODESystem}.
Similarly, the \texttt{ode\_parser.py} module parses \texttt{.ode} files to instances of \texttt{FODEsystem}. 
Alternatively, CLUE can directly parse systems of differential equations written in \texttt{sympy}. 
Regardless of the model source, the creation of instances of \texttt{FODESystem} relies on efficient representation of polynomials and rational functions which are stored in the \texttt{rational\_function.py} module.

%\ToolName supports local models either written using \texttt{sympy}, as ERODE \texttt{.ode} files or they can be pulled directly from the OdeBase repository.
%Systems of ODEs written in \texttt{sympy} can be directly instantiated as CLUE objects.
%Models from the ODEBase repository are directly converted into CLUE objects using the functionality of the \texttt{odebase\_io.py} module.
%Finally \texttt{.ode} are translated to CLUE objects via \texttt{ode\_parser.py}.
%Additional utilities used when parsing rational systems are stored in \texttt{rational\_function.py}.

\subsection{Core functionalities}
The core functionalities of \ToolName are available in the module \texttt{clue.py}.
In this module, the main class is \texttt{FODEsystem} which contains all necessary information to simulate a model e.g., equations, observables, parameters and initial conditions. 
Simulations can be computed via the \texttt{simulate} method.
Additionally, \texttt{FODESystem} offers export functionality to \texttt{.ode} files and to serialized \texttt{.clue} files.
Similarly, it stores the necessary observables and representations of the dynamics to compute lumpings. 

Given an observable, a constrained lumping is computed by finding the smallest invariant subspace from which the evolution of the observable can be recovered. 
Following the  theory presented in~\cite{leguizamon-robayo_approximate_2023, jimenez_clue_2022}, lumpings are computed using the \texttt{lumping} and \texttt{app\_lumping} methods which find exact and approximate lumpings, respectively. 
The outputs of these methods are instances of \texttt{LDESystem}. 
This class inherits from \texttt{FODEsystem}, while including lumping information e.g, the lumping subspace and mappings from the original to the lumped variables.

Exact lumping subspaces are instances of the \texttt{Subspace} class, which stores them as matrices in row-echelon form.
In contrast, approximate lumping subspaces are instances of the \texttt{NumericalSubspace} class, which stores them as orthonormal matrices.
These classes and all linear algebraic computations are stored in the module \texttt{linalg.py}.
%Given an exact lumping $L$, an instance of \texttt{Subspace} stores the space generated by the rows of $L$ in row echelon form, while \texttt{NumericalSubspace} does it using an orthonormal representation.
It should be noted that all exact computations are carried out using the rational number field provided by \texttt{sympy}.
For both numerical and exact computations, we use our own implementation of matrix arithmetic.
Matrices are stored as hash tables where the keys are the nonzero rows and the values are \texttt{SparseVectors} representing the actual row.
Instances of \texttt{SparseVector}  are hash tables storing  the number of the nonzero value as keys and  the actual values of the vector as values.
For example the vector $(0,0,0,1,0,0,2,0,5,0)$ is stored as the hash table $\{ 3:1, 6:2, 9:5\}$.

\subsection{Outputs}
Utilities to handle simulations are provided in the \texttt{simulations.py} module. 
Basic manipulation of simulations and data is supported.
This corresponds to merging, comparing and applying matrices to  simulation results.
Similarly, basic plot functionality is supported, namely, exporting plots and/or simulation data.
 

